# -*- coding: utf-8 -*-
"""Lab_5_Code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oR5Mo9M-UrJLYtveHMjTGEV8mMdhtKav
"""

import pandas as pd
import numpy as np

train_data = pd.read_csv("marketing_train.csv")
test_data = pd.read_csv("marketing_test.csv")

train_data

test_data

# Plots to understand the data
train_data.plot.scatter(x='TV_ads', y='revenue')

train_data.plot.scatter(x='Radio_ads', y='revenue')

train_data.plot.scatter(x='WWW_ads', y='revenue')

"""### Fitting linear regression models"""

from sklearn.linear_model import LinearRegression

# Simple linear regression model with only one attribute WWW_ads
model1 = LinearRegression()
model1.fit(X=train_data[['WWW_ads']], y=train_data['revenue'])

# plot the line to see how it fits the data
# use matplotlib library for more complex plots (colab has matplotlib, for other enviroment, you should install it with pip package manager like previous libraries)
import matplotlib.pyplot as plt

# get model parameters (fitted line slope and intercept)
m = model1.coef_
b = model1.intercept_

print('slope of model 1:', m)
print('intercept of model 1:', b)

plt.scatter(train_data['WWW_ads'], train_data['revenue'])
plt.plot(train_data['WWW_ads'], m*train_data['WWW_ads'] + b, c='red')

"""**Predict Test Data and Evaluate the Model**"""

predicted_val1 = model1.predict(test_data[['WWW_ads']])
print('predicted values using model 1:', predicted_val1)

# get real values in the form of a numpy array
real_values = test_data['revenue'].to_numpy()
print('real values:', real_values)

diff1_array = predicted_val1 - real_values
# convert the difference to absolute values
diff1_array = np.absolute(diff1_array)
diff1_sum = np.sum(diff1_array)

print('the sum of the differences between real and predicted values for model 1 is:', diff1_sum)

print("Mean Absolute Error (MAE) for model 1 is: ", diff1_sum/len(diff1_array))

# now we build a model using two attributes
model2 = LinearRegression()
model2.fit(X=train_data[['WWW_ads', 'TV_ads']], y=train_data['revenue'])

# note that we have 2 slopes now since we have two attributes 
print('slopes of model 2:', model2.coef_)
print('intercept of model 2:', model2.intercept_)

predicted_val2 = model2.predict(test_data[['WWW_ads', 'TV_ads']])
print('predicted values using model 2:', predicted_val2)

# note that real_values are the same and unchanged
print('real values:', real_values)

diff2_array = predicted_val2 - real_values
# convert the difference to absolute values
diff2_array = np.absolute(diff2_array)
diff2_sum = np.sum(diff2_array)

# note that the sum of the differences is less than model 1 (we get better performance)
print('the sum of the differences between real and predicted values for model 2 is:', diff2_sum)

# MAE of model 2 is also smaller than model 1
print("Mean Absolute Error (MAE) for model 2 is: ", diff2_sum/len(diff2_array))

#now we build a model using three attributes
model3 = LinearRegression()
model3.fit(X=train_data[['WWW_ads', 'TV_ads', 'Radio_ads']], y=train_data['revenue'])

# note that we have 3 slopes now since we have three attributes 
print('slopes of model 3:', model3.coef_)
print('intercept of model 3:', model3.intercept_)

predicted_val3 = model3.predict(test_data[['WWW_ads', 'TV_ads', 'Radio_ads']])
print('predicted values using model 3:', predicted_val2)

# note that real_values are the same and unchanged
print('real values:', real_values)

diff3_array = predicted_val3 - real_values
# convert the difference to absolute values
diff3_array = np.absolute(diff3_array)
diff3_sum = np.sum(diff3_array)

# note that the sum of the differences is worse than model 1 (we get lower performance by adding more attributes!)
print('the sum of the differences between real and predicted values for model 3 is:', diff3_sum)

# MAE of model 3 is larger than model 2
print("Mean Absolute Error (MAE) for model 3 is: ", diff3_sum/len(diff3_array))

